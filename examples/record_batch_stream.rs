use std::sync::Arc;

use arrow::{
    array::{
        Array, ArrayBuilder, BooleanArray, BooleanBuilder, StringArray, StringBuilder, StructArray,
        StructBuilder, UInt32Array, UInt32Builder, UInt64Array, UInt64Builder,
    },
    datatypes::{DataType, Field, Fields, SchemaRef},
    record_batch::RecordBatch,
};
use elsm::{
    oracle::LocalOracle,
    record::RecordType,
    schema::{BatchBuilder, Schema, SchemaBuilder},
    serdes::{Decode, Encode},
    stream::record_batch_stream::RecordBatchStream,
    wal::provider::in_mem::InMemProvider,
    Db, DbOption,
};
use elsm_marco::elsm_schema;
use futures::{AsyncRead, AsyncWrite, StreamExt};
use lazy_static::lazy_static;
use tokio::io;

#[derive(Debug, Eq, PartialEq)]
// Use marco `[elsm_schema]` to generate the required implementation
#[elsm_schema]
pub(crate) struct User {
    // primary key must exist and be unique (currently)
    #[primary_key]
    pub(crate) id: u64,
    pub(crate) name: String,
    pub(crate) is_human: bool,
    pub(crate) age: u32,
}

#[tokio::main]
async fn main() {
    let db = Db::new(
        LocalOracle::default(),
        InMemProvider::default(),
        DbOption::new("/simple_crud"),
    )
    .await
    .unwrap();

    // Tips: `UserInner::new` is a method generated by `elsm_schema`
    db.write(
        RecordType::Full,
        0,
        UserInner::new(1, "1".to_string(), true, 0),
    )
    .await
    .unwrap();
    db.write(
        RecordType::Full,
        0,
        UserInner::new(2, "2".to_string(), false, 0),
    )
    .await
    .unwrap();

    let mut stream = RecordBatchStream::new(db.range(None, None, &0).await.unwrap(), 8192);

    assert_eq!(
        stream.next().await.unwrap().unwrap(),
        RecordBatch::try_new(
            UserInner::arrow_schema(),
            vec![
                Arc::new(UInt64Array::from(vec![1, 2])),
                Arc::new(StringArray::from(vec!["1".to_string(), "2".to_string()])),
                Arc::new(BooleanArray::from(vec![true, false])),
                Arc::new(UInt32Array::from(vec![0, 0])),
            ]
        )
        .unwrap()
    );
}
